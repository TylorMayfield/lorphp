<?php

namespace LorPHP\Helpers;

class ModelGenerator {
    private static array $typeMap = [
        'string' => 'string',
        'int' => 'int',
        'integer' => 'int',
        'bool' => 'bool',
        'boolean' => 'bool',
        'datetime' => 'string',
        'float' => 'float',
        'double' => 'float',
        'array' => 'array',
        'object' => 'object',
        'json' => 'array',
        'null' => 'null',
        'mixed' => 'mixed',
        'uuid' => 'string',
        'email' => 'string',
        'phone' => 'string',
        'url' => 'string'
    ];

    private static array $sqliteTypeMap = [
        'string' => 'TEXT',
        'int' => 'INTEGER',
        'integer' => 'INTEGER',
        'bool' => 'INTEGER',
        'boolean' => 'INTEGER',
        'datetime' => 'TEXT',
        'float' => 'REAL',
        'double' => 'REAL',
        'array' => 'TEXT',
        'object' => 'TEXT',
        'json' => 'TEXT',
        'uuid' => 'TEXT',
        'email' => 'TEXT',
        'phone' => 'TEXT',
        'url' => 'TEXT'
    ];

    public static function getPHPType(string $type): string {
        return self::$typeMap[strtolower($type)] ?? 'string';
    }

    public static function getSQLiteType(string $type): string {
        return self::$sqliteTypeMap[strtolower($type)] ?? 'TEXT';
    }

    private static function generateGettersAndSetters(array $fields): string {
        $methods = [];
        
        foreach ($fields as $field => $details) {
            // Skip relationship fields as they have their own generation
            if (isset($details['relationship'])) {
                continue;
            }

            $type = self::getPHPType($details['type'] ?? 'string');
            $methodName = ucfirst($field);
            
            // Getter
            $methods[] = <<<PHP
                
    public function get{$methodName}()
    {
        return \$this->{$field};
    }

    public function set{$methodName}(\${$field}): void
    {
        \$this->{$field} = \${$field};
    }
PHP;
        }

        return implode("\n", $methods);
    }

    private static function generateFileHeader(): string {
        $date = date('Y-m-d H:i:s');
        return <<<PHP
/**
 * This file is auto-generated by LorPHP.
 * Generated on: {$date}
 * 
 * WARNING: Do not edit this file manually.
 * Any changes will be overwritten when the file is regenerated.
 */

PHP;
    }

    public static function generateModelContent(string $entityName, array $fields, string $tableName, array $fillableFields): string {
        $header = self::generateFileHeader();
        $fieldsString = self::generateFieldsDocBlock($fields);
        $relationships = self::generateRelationshipMethods($fields);
        $relationshipProperties = self::generateRelationshipProperties($fields);
        $relationshipImports = self::generateRelationshipImports($fields);
        $gettersAndSetters = self::generateGettersAndSetters($fields);
        $fillableString = '[' . implode(', ', array_map(fn($f) => "'{$f}'", $fillableFields)) . ']';

        return <<<PHP
<?php

{$header}namespace LorPHP\\Models;

use LorPHP\\Core\\Model;
use LorPHP\\Interfaces\\{$entityName}Interface;
{$relationshipImports}

/**
 * Class {$entityName}
 * Represents the {$entityName} entity.
 *
{$fieldsString}{$relationshipProperties} */
class {$entityName} extends Model implements {$entityName}Interface
{
    protected static string \$tableName = '{$tableName}';
    protected static \$fillable = {$fillableString};
{$relationships}{$gettersAndSetters}}

PHP;
    }

    public static function generateMigrationContent(string $tableName, string $className, array $fields): string {
        $header = self::generateFileHeader();
        $columnsPhp = self::generateColumns($fields);

        return <<<PHP
<?php

{$header}namespace LorPHP\\Database\\Migrations;

use LorPHP\\Core\\Migration;
use LorPHP\\Core\\Schema;

class {$className} extends Migration
{
    public function up()
    {
        \$this->createTable('{$tableName}', function(Schema \$table) {
{$columnsPhp}
        });
    }

    public function down()
    {
        \$this->dropTable('{$tableName}');
    }
}

PHP;
    }

    private static function generateFieldsDocBlock(array $fields): string {
        $fieldsString = '';
        foreach ($fields as $field => $details) {
            if (isset($details['relationship'])) continue;
            $type = self::getPHPType($details['type'] ?? 'string');
            $fieldsString .= " * @property {$type} \${$field}\n";
        }
        return $fieldsString;
    }

    private static function generateColumns(array $fields): string {
        $columnsPhp = '';
        foreach ($fields as $field => $details) {
            if (isset($details['relationship'])) continue;

            $type = $details['type'] ?? 'string';
            $attributes = $details['attributes'] ?? [];
            $nullable = $details['nullable'] ?? false;
            
            // Map types to Schema methods
            $method = match(strtolower($type)) {
                'int', 'integer' => 'integer',
                'text', 'string' => 'string',
                'bool', 'boolean' => 'boolean',
                'float', 'double', 'decimal' => 'decimal',
                'datetime', 'timestamp' => 'timestamp',
                default => 'string'
            };
            
            $columnDef = "            \$table->{$method}('$field'";
            
            // Handle special types that might need parameters
            if ($method === 'decimal') {
                $columnDef .= ", 10, 2"; // Default precision and scale
            } else if ($method === 'timestamp' && isset($details['default']) && $details['default'] === 'CURRENT_TIMESTAMP') {
                $columnDef .= ", 'CURRENT_TIMESTAMP'";
            }
            $columnDef .= ")";

            // Add modifiers
            if ($field === 'id') {
                $columnDef = "            \$table->uuid()";
            }
            if (in_array('@unique', $attributes)) {
                $columnDef .= "->unique()";
            }
            if ($nullable || (isset($details['default']) && $details['default'] === null)) {
                $columnDef .= "->nullable()";
            }
            if (isset($details['default']) && $details['default'] !== null && $details['default'] !== 'CURRENT_TIMESTAMP') {
                $default = is_string($details['default']) ? "'{$details['default']}'" : $details['default'];
                $columnDef .= "->default($default)";
            }
            
            $columnsPhp .= $columnDef . ";\n";
        }
        return $columnsPhp;
    }

    private static function generateRelationshipMethods(array $fields): string {
        $methods = '';
        foreach ($fields as $field => $details) {
            if (isset($details['relationship'])) {
                $relationType = $details['relationship']['type'] ?? '';
                $relatedModel = $details['relationship']['model'] ?? '';
                $foreignKey = $details['relationship']['foreignKey'] ?? '';

                if ($relationType && $relatedModel) {
                    switch (strtolower($relationType)) {
                        case 'belongsto':
                            $methods .= "\n    public function " . lcfirst($field) . "()\n    {";
                            $methods .= "\n        return \$this->belongsTo(" . $relatedModel . "::class, '" . $foreignKey . "');";
                            $methods .= "\n    }\n";
                            break;
                        case 'hasmany':
                            $methods .= "\n    public function " . lcfirst($field) . "()\n    {";
                            $methods .= "\n        return \$this->hasMany(" . $relatedModel . "::class, '" . $foreignKey . "');";
                            $methods .= "\n    }\n";
                            break;
                        case 'hasone':
                            $methods .= "\n    public function " . lcfirst($field) . "()\n    {";
                            $methods .= "\n        return \$this->hasOne(" . $relatedModel . "::class, '" . $foreignKey . "');";
                            $methods .= "\n    }\n";
                            break;
                    }
                }
            }
        }
        return $methods;
    }

    private static function generateRelationshipProperties(array $fields): string {
        $properties = '';
        foreach ($fields as $field => $details) {
            if (isset($details['relationship'])) {
                $relatedModel = $details['relationship']['model'] ?? '';
                if ($relatedModel) {
                    $properties .= " * @property " . $relatedModel . " \$" . $field . "\n";
                }
            }
        }
        return $properties;
    }

    private static function generateRelationshipImports(array $fields): string {
        $imports = '';
        $models = [];
        foreach ($fields as $details) {
            if (isset($details['relationship']['model'])) {
                $models[] = $details['relationship']['model'];
            }
        }
        $models = array_unique($models);
        foreach ($models as $model) {
            $imports .= "use LorPHP\\Models\\{$model};\n";
        }
        return $imports;
    }
}
