<?php

namespace LorPHP\Helpers;

class ModelGenerator {
    private static array $typeMap = [
        'string' => 'string',
        'int' => 'int',
        'integer' => 'int',
        'bool' => 'bool',
        'boolean' => 'bool',
        'datetime' => 'string',
        'float' => 'float',
        'double' => 'float',
        'array' => 'array',
        'object' => 'object',
        'json' => 'array',
        'null' => 'null',
        'mixed' => 'mixed',
        'uuid' => 'string',
        'email' => 'string',
        'phone' => 'string',
        'url' => 'string'
    ];

    private static array $sqliteTypeMap = [
        'string' => 'TEXT',
        'int' => 'INTEGER',
        'integer' => 'INTEGER',
        'bool' => 'INTEGER',
        'boolean' => 'INTEGER',
        'datetime' => 'TEXT',
        'float' => 'REAL',
        'double' => 'REAL',
        'array' => 'TEXT',
        'object' => 'TEXT',
        'json' => 'TEXT',
        'uuid' => 'TEXT',
        'email' => 'TEXT',
        'phone' => 'TEXT',
        'url' => 'TEXT'
    ];

    public static function getPHPType(string $type): string {
        return self::$typeMap[strtolower($type)] ?? 'string';
    }

    public static function getSQLiteType(string $type): string {
        return self::$sqliteTypeMap[strtolower($type)] ?? 'TEXT';
    }

    private static function generateFinderMethods(array $fields): string {
        $methods = [];
        
        foreach ($fields as $field => $details) {
            // Skip relationship fields
            if (isset($details['relationship'])) {
                continue;
            }
            
            // Check if field has unique attribute
            $hasUniqueAttribute = false;
            if (isset($details['attributes']) && is_array($details['attributes'])) {
                $hasUniqueAttribute = in_array('@unique', $details['attributes']);
            }
            
            if ($hasUniqueAttribute) {
                $type = self::getPHPType($details['type'] ?? 'string');
                $methodName = ucfirst($field);
                $nullableType = isset($details['nullable']) && $details['nullable'] ? "?$type" : $type;
                
                $methods[] = <<<PHP
                
    /**
     * Find a record by its {$field}
     * @param {$type} \${$field} The {$field} to search for
     * @return static|null The record if found, null otherwise
     */
    public static function findBy{$methodName}({$nullableType} \${$field}): ?static
    {
        \$db = \LorPHP\Core\Database::getInstance();
        \$data = \$db->findOne(static::\$tableName, ['{$field}' => \${$field}]);
        
        if (\$data) {
            \$model = new static();
            \$model->fill(\$data);
            return \$model;
        }
        
        return null;
    }
PHP;
            }
        }

        return implode("\n", $methods);
    }    private static function generateGettersAndSetters(array $fields): string {
        $methods = [];
        
        foreach ($fields as $field => $details) {
            // Skip relationship fields as they have their own generation
            if (isset($details['relationship'])) {
                continue;
            }

            $type = self::getPHPType($details['type'] ?? 'string');
            
            // Generate both camelCase and snake_case versions
            $camelField = $field;
            $snakeField = strtolower(preg_replace('/(?<!^)[A-Z]/', '_$0', $field));
            
            if ($camelField !== $snakeField) {
                // Generate snake_case version for interface compatibility
                $snakeMethodName = str_replace('_', '', ucwords($snakeField, '_'));
                $methods[] = <<<PHP
                
    public function get{$snakeMethodName}()
    {
        return \$this->{$camelField};
    }

    public function set{$snakeMethodName}(\${$snakeField}): void
    {
        \$this->{$camelField} = \${$snakeField};
    }
PHP;
            }
            
            // Generate camelCase version for convenience
            $camelMethodName = ucfirst($camelField);
            $methods[] = <<<PHP
                
    public function get{$camelMethodName}()
    {
        return \$this->{$camelField};
    }

    public function set{$camelMethodName}(\${$camelField}): void
    {
        \$this->{$camelField} = \${$camelField};
    }
PHP;
        }

        return implode("\n", $methods);
    }

    private static function generateFileHeader(): string {
        $date = date('Y-m-d H:i:s');
        return <<<PHP
/**
 * This file is auto-generated by LorPHP.
 * Generated on: {$date}
 * 
 * WARNING: Do not edit this file manually.
 * Any changes will be overwritten when the file is regenerated.
 */

PHP;
    }    private static function generateRelationshipMethods(array $fields): string {
        $methods = [];
        
        foreach ($fields as $field => $details) {
            // Generate custom methods defined in the schema
            if (isset($details['methods'])) {
                foreach ($details['methods'] as $methodName => $methodDetails) {
                    $returnType = $methodDetails['returns'];
                    // Convert array notation to PHP return type                    $phpReturnType = 'array';
                    if (str_ends_with($returnType, '[]')) {
                        $itemType = substr($returnType, 0, -2);
                        $docReturnType = "$itemType[]";
                    } else {
                        $docReturnType = $returnType;
                        $phpReturnType = str_ends_with($returnType, '[]') ? 'array' : $returnType;
                    }
                    
                    $filterParam = '';
                    $filterDoc = '';
                    if (isset($methodDetails['filter']) && $methodDetails['filter']) {
                        $filterParam = 'array $filters = []';
                        $filterDoc = "@param array \$filters Optional filters to apply\n     * ";
                    }
                    
                    $methods[] = <<<PHP
                
    /**
     * {$methodDetails['description']}
     * {$filterDoc}@return {$docReturnType}
     */
    public function {$methodName}($filterParam): {$phpReturnType} 
    {
        if (!isset(\$this->relations['{$field}'])) {
            \$this->loadRelation('{$field}', {$field}::class);
        }
        
        if (!isset(\$this->relations['{$field}'])) {
            return [];
        }
        
        \$items = \$this->relations['{$field}']->{$methodName}();
        return \$items;
    }
PHP;
                }
            }

            if (!isset($details['relationship'])) {
                continue;
            }

            $type = $details['type'];
            $relationship = $details['relationship'];
            $methodName = ucfirst($field);
            
            // Create the relationship method that will be called by the magic getter
            $relationshipType = match($relationship) {
                'many-to-many' => 'manyToMany',
                'one-to-many' => 'hasMany',
                'many-to-one' => 'belongsTo',
                'one-to-one' => 'hasOne',
                default => 'hasOne'
            };

            // Add magic property getter
            $methods[] = <<<PHP
                
    /**
     * Get related {$field}
     * @return {$type}[]
     */
    public function {$field}()
    {
        return \$this->{$relationshipType}({$type}::class);
    }
PHP;

            // Add normal getter/setter methods
            $methods[] = <<<PHP
                
    public function get{$methodName}()
    {
        return \$this->{$field}();
    }

    public function set{$methodName}(\${$field}): void
    {
        \$this->{$field} = \${$field};
    }
PHP;
        }

        return implode("\n", $methods);
    }

    private static function handleArrayReturnType(string $returnType): array {
        $phpReturnType = 'array';
        $docReturnType = $returnType;
        
        // If the type ends in [] or is itself an array, use array for PHP return type
        if (str_contains($returnType, '[]') || $returnType === 'array') {
            if (str_ends_with($returnType, '[]')) {
                $itemType = substr($returnType, 0, -2);
                $docReturnType = "$itemType[]";
            }
        } else {
            $phpReturnType = $returnType;
        }
        
        return [$phpReturnType, $docReturnType];
    }

    private static function generateCustomRelationshipMethods(array $fields): string {
        $methods = [];
        
        foreach ($fields as $field => $details) {
            if (!isset($details['methods'])) {
                continue;
            }

            foreach ($details['methods'] as $methodName => $methodDetails) {
                $returnType = $methodDetails['returns'] ?? 'array';
                [$phpReturnType, $docReturnType] = self::handleArrayReturnType($returnType);
                $description = $methodDetails['description'] ?? '';
                $filter = $methodDetails['filter'] ?? false;

                if ($filter) {
                    $methods[] = <<<PHP
                
    /**
     * {$description}
     * @param array \$filters Optional filters to apply
     * @return {$docReturnType}
     */
    public function {$methodName}(array \$filters = []): {$phpReturnType} 
    {
        if (!isset(\$this->relations['{$field}'])) {
            \$this->loadRelation('{$field}', {$field}::class);
        }
        
        if (!isset(\$this->relations['{$field}'])) {
            return [];
        }
        
        \$items = \$this->relations['{$field}']->{$methodName}();
        
        if (empty(\$filters)) {
            return \$items;
        }
        
        return array_filter(\$items, function(\$item) use (\$filters) {
            foreach (\$filters as \$key => \$value) {
                if (\$item->{\$key} !== \$value) {
                    return false;
                }
            }
            return true;
        });
    }
PHP;
                } else {
                    $methods[] = <<<PHP
                
    /**
     * {$description}
     * @return {$docReturnType}
     */
    public function {$methodName}(): {$phpReturnType} 
    {
        if (!isset(\$this->relations['{$field}'])) {
            \$this->loadRelation('{$field}', {$field}::class);
        }
        
        if (!isset(\$this->relations['{$field}'])) {
            return [];
        }
        
        return \$this->relations['{$field}']->{$methodName}();
    }
PHP;
                }
            }
        }

        return implode("\n", $methods);
    }

    private static function generateSaveMethod(): string {
        return <<<PHP

    public function save(): bool {
        return parent::save();
    }
PHP;
    }    public static function generateModelContent(string $entityName, array $fields, string $tableName, array $fillableFields): string {
        $header = self::generateFileHeader();
        $fieldsString = self::generateFieldsDocBlock($fields);
        $relationships = self::generateRelationshipMethods($fields);
        $finderMethods = self::generateFinderMethods($fields);
        $gettersAndSetters = self::generateGettersAndSetters($fields);
        $customMethods = self::generateCustomRelationshipMethods($fields);
        $saveMethod = self::generateSaveMethod();
        
        // Add both camelCase and snake_case versions to fillable
        $allFillableFields = [];
        foreach ($fillableFields as $field) {
            $allFillableFields[] = $field;
            $allFillableFields[] = strtolower(preg_replace('/(?<!^)[A-Z]/', '_$0', $field));
        }
        $fillableString = '[' . implode(', ', array_map(fn($f) => "'{$f}'", $allFillableFields)) . ']';
        
        // Add imports for related models
        $imports = ["use LorPHP\\Core\\Model;", "use LorPHP\\Interfaces\\{$entityName}Interface;"];
        foreach ($fields as $field => $details) {
            if (isset($details['type']) && isset($details['relationship'])) {
                $imports[] = "use LorPHP\\Models\\{$details['type']};";
            }
        }
        $imports = array_unique($imports);
        $importsString = implode("\n", $imports);

        return <<<PHP
<?php

{$header}namespace LorPHP\\Models;

{$importsString}

/**
 * Class {$entityName}
 * Represents the {$entityName} entity.
 *
{$fieldsString} */
class {$entityName} extends Model implements {$entityName}Interface
{
    protected static string \$tableName = '{$tableName}';
    protected static \$fillable = {$fillableString};
                
{$finderMethods}
{$relationships}
{$gettersAndSetters}
{$customMethods}
{$saveMethod}}

PHP;
    }

    public static function generateMigrationContent(string $tableName, string $className, array $fields): string {
        $header = self::generateFileHeader();
        $columnsPhp = self::generateColumns($fields);

        return <<<PHP
<?php

{$header}namespace LorPHP\\Database\\Migrations;

use LorPHP\\Core\\Migration;
use LorPHP\\Core\\Schema;

class {$className} extends Migration
{
    public function up()
    {
        \$this->createTable('{$tableName}', function(Schema \$table) {
{$columnsPhp}
        });
    }

    public function down()
    {
        \$this->dropTable('{$tableName}');
    }
}

PHP;
    }

    private static function generateFieldsDocBlock(array $fields): string {
        $fieldsString = '';
        foreach ($fields as $field => $details) {
            if (isset($details['relationship'])) continue;
            $type = self::getPHPType($details['type'] ?? 'string');
            $fieldsString .= " * @property {$type} \${$field}\n";
        }
        return $fieldsString;
    }

    private static function generateColumns(array $fields): string {
        $columnsPhp = '';
        foreach ($fields as $field => $details) {
            if (isset($details['relationship'])) continue;

            $type = $details['type'] ?? 'string';
            $attributes = $details['attributes'] ?? [];
            $nullable = $details['nullable'] ?? false;
            
            // Map types to Schema methods
            $method = match(strtolower($type)) {
                'int', 'integer' => 'integer',
                'text', 'string' => 'string',
                'bool', 'boolean' => 'boolean',
                'float', 'double', 'decimal' => 'decimal',
                'datetime', 'timestamp' => 'timestamp',
                default => 'string'
            };
            
            $columnDef = "            \$table->{$method}('$field'";
            
            // Handle special types that might need parameters
            if ($method === 'decimal') {
                $columnDef .= ", 10, 2"; // Default precision and scale
            } else if ($method === 'timestamp' && isset($details['default']) && $details['default'] === 'CURRENT_TIMESTAMP') {
                $columnDef .= ", 'CURRENT_TIMESTAMP'";
            }
            $columnDef .= ")";

            // Add modifiers
            if ($field === 'id') {
                $columnDef = "            \$table->uuid()";
            }
            if (in_array('@unique', $attributes)) {
                $columnDef .= "->unique()";
            }
            if ($nullable || (isset($details['default']) && $details['default'] === null)) {
                $columnDef .= "->nullable()";
            }
            if (isset($details['default']) && $details['default'] !== null && $details['default'] !== 'CURRENT_TIMESTAMP') {
                $default = is_string($details['default']) ? "'{$details['default']}'" : $details['default'];
                $columnDef .= "->default($default)";
            }
            
            $columnsPhp .= $columnDef . ";\n";
        }
        return $columnsPhp;
    }

    private static function generateRelationshipProperties(array $fields): string {
        $properties = '';
        foreach ($fields as $field => $details) {
            if (isset($details['relationship'])) {
                $relatedModel = $details['relationship']['model'] ?? '';
                if ($relatedModel) {
                    $properties .= " * @property " . $relatedModel . " \$" . $field . "\n";
                }
            }
        }
        return $properties;
    }

    private static function generateRelationshipImports(array $fields): string {
        $imports = '';
        $models = [];
        foreach ($fields as $details) {
            if (isset($details['relationship']['model'])) {
                $models[] = $details['relationship']['model'];
            }
        }
        $models = array_unique($models);
        foreach ($models as $model) {
            $imports .= "use LorPHP\\Models\\{$model};\n";
        }
        return $imports;
    }
}
