<?php

namespace LorPHP\Helpers;

class ModelGenerator {
    private static array $typeMap = [
        'string' => 'string',
        'int' => 'int',
        'integer' => 'int',
        'bool' => 'bool',
        'boolean' => 'bool',
        'datetime' => 'string',
        'float' => 'float',
        'double' => 'float',
        'array' => 'array',
        'object' => 'object',
        'json' => 'array',
        'null' => 'null',
        'mixed' => 'mixed',
        'uuid' => 'string',
        'email' => 'string',
        'phone' => 'string',
        'url' => 'string'
    ];

    private static array $sqliteTypeMap = [
        'string' => 'TEXT',
        'int' => 'INTEGER',
        'integer' => 'INTEGER',
        'bool' => 'INTEGER',
        'boolean' => 'INTEGER',
        'datetime' => 'TEXT',
        'float' => 'REAL',
        'double' => 'REAL',
        'array' => 'TEXT',
        'object' => 'TEXT',
        'json' => 'TEXT',
        'uuid' => 'TEXT',
        'email' => 'TEXT',
        'phone' => 'TEXT',
        'url' => 'TEXT'
    ];

    public static function getPHPType(string $type): string {
        return self::$typeMap[strtolower($type)] ?? 'string';
    }

    public static function getSQLiteType(string $type): string {
        return self::$sqliteTypeMap[strtolower($type)] ?? 'TEXT';
    }

    private static function generateFinderMethods(array $fields): string {
        $methods = [];
        
        foreach ($fields as $field => $details) {
            // Skip relationship fields
            if (isset($details['relationship'])) {
                continue;
            }
            
            // Check if field has unique attribute
            $hasUniqueAttribute = false;
            if (isset($details['attributes']) && is_array($details['attributes'])) {
                $hasUniqueAttribute = in_array('@unique', $details['attributes']);
            }
            
            if ($hasUniqueAttribute) {
                $type = self::getPHPType($details['type'] ?? 'string');
                $methodName = ucfirst($field);
                $nullableType = isset($details['nullable']) && $details['nullable'] ? "?$type" : $type;
                
                $methods[] = <<<PHP
                
    /**
     * Find a record by its {$field}
     * @param {$type} \${$field} The {$field} to search for
     * @return static|null The record if found, null otherwise
     */
    public static function findBy{$methodName}({$nullableType} \${$field}): ?static
    {
        \$db = \LorPHP\Core\Database::getInstance();
        \$data = \$db->findOne(static::\$tableName, ['{$field}' => \${$field}]);
        
        if (\$data) {
            \$model = new static();
            \$model->fill(\$data);
            return \$model;
        }
        
        return null;
    }
PHP;
            }
        }

        return implode("\n", $methods);
    }

    private static function generateGettersAndSetters(array $fields): string {
        $methods = [];
        
        foreach ($fields as $field => $details) {
            // Skip relationship fields as they have their own generation
            if (isset($details['relationship'])) {
                continue;
            }

            $type = self::getPHPType($details['type'] ?? 'string');
            $methodName = ucfirst($field);
            
            // Getter
            $methods[] = <<<PHP
                
    public function get{$methodName}()
    {
        return \$this->{$field};
    }

    public function set{$methodName}(\${$field}): void
    {
        \$this->{$field} = \${$field};
    }
PHP;
        }

        return implode("\n", $methods);
    }

    private static function generateFileHeader(): string {
        $date = date('Y-m-d H:i:s');
        return <<<PHP
/**
 * This file is auto-generated by LorPHP.
 * Generated on: {$date}
 * 
 * WARNING: Do not edit this file manually.
 * Any changes will be overwritten when the file is regenerated.
 */

PHP;
    }

    private static function generateRelationshipMethods(array $fields): string {
        $methods = [];
        
        foreach ($fields as $field => $details) {
            if (!isset($details['relationship'])) {
                continue;
            }

            $type = $details['type'];
            $relationship = $details['relationship'];
            $methodName = ucfirst($field);
            
            // Create the relationship method that will be called by the magic getter
            $relationshipType = match($relationship) {
                'many-to-many' => 'manyToMany',
                'one-to-many' => 'hasMany',
                'many-to-one' => 'belongsTo',
                'one-to-one' => 'hasOne',
                default => 'hasOne'
            };

            // Add magic property getter
            $methods[] = <<<PHP
                
    /**
     * Get related {$field}
     * @return {$type}[]
     */
    public function {$field}()
    {
        return \$this->{$relationshipType}({$type}::class);
    }
PHP;

            // Add normal getter/setter methods
            $methods[] = <<<PHP
                
    public function get{$methodName}()
    {
        return \$this->{$field}();
    }

    public function set{$methodName}(\${$field}): void
    {
        \$this->{$field} = \${$field};
    }
PHP;
        }

        return implode("\n", $methods);
    }

    public static function generateModelContent(string $entityName, array $fields, string $tableName, array $fillableFields): string {
        $header = self::generateFileHeader();
        $fieldsString = self::generateFieldsDocBlock($fields);
        $relationships = self::generateRelationshipMethods($fields);
        $finderMethods = self::generateFinderMethods($fields);
        $gettersAndSetters = self::generateGettersAndSetters($fields);
        $fillableString = '[' . implode(', ', array_map(fn($f) => "'{$f}'", $fillableFields)) . ']';
        
        // Add imports for related models
        $imports = ["use LorPHP\\Core\\Model;", "use LorPHP\\Interfaces\\{$entityName}Interface;"];
        foreach ($fields as $field => $details) {
            if (isset($details['type']) && isset($details['relationship'])) {
                $imports[] = "use LorPHP\\Models\\{$details['type']};";
            }
        }
        $imports = array_unique($imports);
        $importsString = implode("\n", $imports);

        return <<<PHP
<?php

{$header}namespace LorPHP\\Models;

{$importsString}

/**
 * Class {$entityName}
 * Represents the {$entityName} entity.
 *
{$fieldsString} */
class {$entityName} extends Model implements {$entityName}Interface
{
    protected static string \$tableName = '{$tableName}';
    protected static \$fillable = {$fillableString};
                
{$finderMethods}
{$relationships}
{$gettersAndSetters}}

PHP;
    }

    public static function generateMigrationContent(string $tableName, string $className, array $fields): string {
        $header = self::generateFileHeader();
        $columnsPhp = self::generateColumns($fields);

        return <<<PHP
<?php

{$header}namespace LorPHP\\Database\\Migrations;

use LorPHP\\Core\\Migration;
use LorPHP\\Core\\Schema;

class {$className} extends Migration
{
    public function up()
    {
        \$this->createTable('{$tableName}', function(Schema \$table) {
{$columnsPhp}
        });
    }

    public function down()
    {
        \$this->dropTable('{$tableName}');
    }
}

PHP;
    }

    private static function generateFieldsDocBlock(array $fields): string {
        $fieldsString = '';
        foreach ($fields as $field => $details) {
            if (isset($details['relationship'])) continue;
            $type = self::getPHPType($details['type'] ?? 'string');
            $fieldsString .= " * @property {$type} \${$field}\n";
        }
        return $fieldsString;
    }

    private static function generateColumns(array $fields): string {
        $columnsPhp = '';
        foreach ($fields as $field => $details) {
            if (isset($details['relationship'])) continue;

            $type = $details['type'] ?? 'string';
            $attributes = $details['attributes'] ?? [];
            $nullable = $details['nullable'] ?? false;
            
            // Map types to Schema methods
            $method = match(strtolower($type)) {
                'int', 'integer' => 'integer',
                'text', 'string' => 'string',
                'bool', 'boolean' => 'boolean',
                'float', 'double', 'decimal' => 'decimal',
                'datetime', 'timestamp' => 'timestamp',
                default => 'string'
            };
            
            $columnDef = "            \$table->{$method}('$field'";
            
            // Handle special types that might need parameters
            if ($method === 'decimal') {
                $columnDef .= ", 10, 2"; // Default precision and scale
            } else if ($method === 'timestamp' && isset($details['default']) && $details['default'] === 'CURRENT_TIMESTAMP') {
                $columnDef .= ", 'CURRENT_TIMESTAMP'";
            }
            $columnDef .= ")";

            // Add modifiers
            if ($field === 'id') {
                $columnDef = "            \$table->uuid()";
            }
            if (in_array('@unique', $attributes)) {
                $columnDef .= "->unique()";
            }
            if ($nullable || (isset($details['default']) && $details['default'] === null)) {
                $columnDef .= "->nullable()";
            }
            if (isset($details['default']) && $details['default'] !== null && $details['default'] !== 'CURRENT_TIMESTAMP') {
                $default = is_string($details['default']) ? "'{$details['default']}'" : $details['default'];
                $columnDef .= "->default($default)";
            }
            
            $columnsPhp .= $columnDef . ";\n";
        }
        return $columnsPhp;
    }

    private static function generateRelationshipProperties(array $fields): string {
        $properties = '';
        foreach ($fields as $field => $details) {
            if (isset($details['relationship'])) {
                $relatedModel = $details['relationship']['model'] ?? '';
                if ($relatedModel) {
                    $properties .= " * @property " . $relatedModel . " \$" . $field . "\n";
                }
            }
        }
        return $properties;
    }

    private static function generateRelationshipImports(array $fields): string {
        $imports = '';
        $models = [];
        foreach ($fields as $details) {
            if (isset($details['relationship']['model'])) {
                $models[] = $details['relationship']['model'];
            }
        }
        $models = array_unique($models);
        foreach ($models as $model) {
            $imports .= "use LorPHP\\Models\\{$model};\n";
        }
        return $imports;
    }
}
